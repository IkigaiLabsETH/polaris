package miner

import (
	"fmt"
	"math/big"
	"sync"

	"github.com/ethereum/go-ethereum/consensus"
	"github.com/ethereum/go-ethereum/consensus/misc"
	"github.com/ethereum/go-ethereum/core"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/miner"
	"github.com/rs/zerolog/log"
	"pkg.berachain.dev/polaris/eth/api"
	"pkg.berachain.dev/polaris/eth/common"
	"pkg.berachain.dev/polaris/eth/params"
)

type Environment = miner.Environment

// GenerateParams wraps various of settings for generating sealing task.
type GenerateParams struct {
	timestamp   uint64            // The timstamp for sealing task
	forceTime   bool              // Flag whether the given timestamp is immutable or not
	parentHash  common.Hash       // Parent block hash, empty means the latest chain head
	coinbase    common.Address    // The fee recipient address for including transaction
	random      common.Hash       // The randomness generated by beacon chain, empty before the merge
	withdrawals types.Withdrawals // List of withdrawals to include in block.
	noUncle     bool              // Flag whether the uncle block inclusion is allowed
	noTxs       bool              // Flag whether an empty block without any transaction is expected
}

type Worker struct {
	mu          sync.RWMutex // The lock used to protect the coinbase and extra fields
	chain       api.Chain
	config      *miner.Config
	chainConfig *params.ChainConfig
	engine      consensus.Engine
	// eth         Backend
	extra   []byte
	gasCeil uint64
}

func (w *Worker) PrepareWork(genParams *GenerateParams) (*Environment, error) {
	w.mu.RLock()
	defer w.mu.RUnlock()

	// Find the parent block for sealing task
	var parent *types.Header
	parentBlock, _ := w.chain.CurrentBlock()
	if genParams.parentHash != (common.Hash{}) {
		parentBlock, _ = w.chain.GetBlockByHash(genParams.parentHash)
		if parent == nil {
			return nil, fmt.Errorf("missing parent")
		}
		parent = parentBlock.Header()
	}

	// Sanity check the timestamp correctness, recap the timestamp
	// to parent+1 if the mutation is allowed.
	timestamp := genParams.timestamp
	if parent.Time >= timestamp {
		if genParams.forceTime {
			return nil, fmt.Errorf("invalid timestamp, parent %d given %d", parent.Time, timestamp)
		}
		timestamp = parent.Time + 1
	}
	// Construct the sealing block header.
	header := &types.Header{
		ParentHash: parent.Hash(),
		Number:     new(big.Int).Add(parent.Number, big.NewInt(1)),
		GasLimit:   core.CalcGasLimit(parent.GasLimit, w.gasCeil),
		Time:       timestamp,
		Coinbase:   genParams.coinbase,
	}

	// Set the extra field.
	if len(w.extra) != 0 {
		header.Extra = w.extra
	}
	// Set the randomness field from the beacon chain if it's available.
	if genParams.random != (common.Hash{}) {
		header.MixDigest = genParams.random
	}
	// Set baseFee and GasLimit if we are on an EIP-1559 chain
	if w.chainConfig.IsLondon(header.Number) {
		header.BaseFee = misc.CalcBaseFee(w.chainConfig, parent)
		if !w.chainConfig.IsLondon(parent.Number) {
			parentGasLimit := parent.GasLimit * w.chainConfig.ElasticityMultiplier()
			header.GasLimit = core.CalcGasLimit(parentGasLimit, w.config.GasCeil)
		}
	}
	// Run the consensus preparation with the default or customized consensus engine.
	if err := w.engine.Prepare(w.chain, header); err != nil {
		log.Error("Failed to prepare header for sealing", "err", err)
		return nil, err
	}
	// Could potentially happen if starting to mine in an odd state.
	// Note genParams.coinbase can be different with header.Coinbase
	// since clique algorithm can modify the coinbase field in header.
	env, err := w.makeEnv(parent, header, genParams.coinbase)
	if err != nil {
		log.Error("Failed to create sealing context", "err", err)
		return nil, err
	}
}
